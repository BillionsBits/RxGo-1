package rxgo

type rangeIterable(type T) struct {
	start, count int
	opts         [](Option(T))
}

func newRangeIterable(start, count int, opts ...Option) Iterable {
	return &rangeIterable{
		start: start,
		count: count,
		opts:  opts,
	}
}

func (i *rangeIterable) Observe(opts ...Option(T)) <-chan(Item(T)) {
	option := parseOptions(append(i.opts, opts...)...)
	ctx := option.buildContext()
	next := option.buildChannel()

	go func() {
		for idx := i.start; idx <= i.start+i.count; idx++ {
			select {
			case <-ctx.Done():
				return
			case next <- Of(idx):
			}
		}
		close(next)
	}()
	return next
}
